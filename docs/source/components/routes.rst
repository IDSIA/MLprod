==========
API Routes
==========

In this page we will go through all the routes we implemented with *FastAPI*.

Each route is basically a web URL that accept data in JSON format, performs some operations and then reply with a status code and a result.

The status code can be used to discriminate if a request has been executed successfully (``2xx`` values) or if there was an internal error on the server (``5xx`` values) or an error from the client (``4xx`` values).

Data exchange
=============

Before getting into details, we need to introduce how data is shared between the user and the application.
Following the best practices, data has to be shared in a structured way (a JSON for example). FastAPI has some neat way to do this using a module called `pydantic`_.

*Pydantic* defines the format of the data using Python classes, in this way it is possible to shape the information in a strict format making them easy to manage.
In the following snippet of code, there are the classes we wrote to define the structure of the data. A brief explanation of what each class defines is written as a comment.

An example of a data definition class is shown below, full class implementation can be found in *api/requests.py*.

.. literalinclude:: ../../../api/requests.py
    :language: python
    :linenos:
    :lines: 5-9

This class will let the API produce a JSON containing three fields: ``task_id`` is an unique identifier for the task started; ``status`` defines the current status of task; ``type`` is an extra field that tells the user which kind of task has been started.

Routes
======

Now we do a brief explanation of each route implemented in out API.

/inference/start
----------------

.. literalinclude:: ../../../api/routes.py
    :language: python
    :linenos:
    :lines: 51-63

``/inference/start`` is used to start an inference task with the current active model.

This route receive as parameters:

    * the user's data which contains an ID and some features,
    * a open session to a database generated by FastAPI.

First of all, we log the event in the database at line 54, then we store the received data.
At line 6 we start the asynchronous process by telling Celery to spawn an *inference* task.
``user_id`` is then used to retrieve the data stored in the database at line 5.

At line 8 we insert a new entry in the database that help the user tracking the status of the task.
Once the task is finished, the user can retrieve the predictions using another route.

The route, at the end, return the status of the task to the user.

/inference/status/{task_id}
---------------------------

.. literalinclude:: ../../../api/routes.py
    :language: python
    :linenos:
    :lines: 66-96

``/inference/status/{task_id}`` is used to check the status of the task running asynchronously.

This route accept as parameter the *task_id* associated to the process spawned by celery.

The extra code is similar to the previous route: it tracks the event and contains the logic to create the correct response.

/inference/results/{task_id}
----------------------------

.. literalinclude:: ../../../api/routes.py
    :language: python
    :lines: 99-112
    :linenos:

``/inference/results/{task_id}`` is used to retrieve the results of the inference once the response of ``/inference/status/{task_id}`` notify the successful completion of an inference.

Note how on line 10 we get from the database the locations with the score produced by the inference.

/inference/select/
------------------

.. literalinclude:: ../../../api/routes.py
    :language: python
    :lines: 115-132
    :linenos:

Since we want to simulate the act of a user that *selects* the desired location from a list, we use the ``/inference/select`` route for this purpose.

The routes expects to receive an id that indicates the selection of an user. This creates an history of labelled data that can be used to train a new model.

In the case no location has been selected, we register a *bad_inference* event on our log. Otherwise, we update the data in the database.

/train/start
------------

.. literalinclude:: ../../../api/routes.py
    :language: python
    :lines: 135-147
    :linenos:

The training of a new model is an operation that can be started manually only.
This routes schedule the second type of task on Celery.

/content/...
------------

The routes that begins with ``/content`` are used to debug what is stored in the database.

These routes are reported there as a demonstrative example and can be simply ignored.

.. literalinclude:: ../../../api/routes.py
    :language: python
    :lines: 150-188
    :linenos:


.. _pydantic: https://pydantic-docs.helpmanual.io/